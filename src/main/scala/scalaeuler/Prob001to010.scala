package scalaeuler

import Util.???
import Maths.fibs
import Maths.primes
import scala.annotation.tailrec

object Prob001to010 {
  /**
   * Multiples of 3 and 5
   * http://projecteuler.net/problem=1
   *
   * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
   * Find the sum of all the multiples of 3 or 5 below 1000.
   */
  def prob001: Long = Range(1,1000).filter{ x => x % 3 == 0 || x % 5 == 0 }.sum

  /**
   * Even Fibonacci numbers
   * http://projecteuler.net/problem=2
   *
   * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
   * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
   * By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
   */
  def prob002: Long = fibs.filter(_ % 2 == 0).takeWhile(_ < 4000000).sum

  /**
   * Largest prime factor
   * http://projecteuler.net/problem=3
   *
   * The prime factors of 13195 are 5, 7, 13 and 29.
   * What is the largest prime factor of the number 600851475143 ?
   */
   def prob003: Long = {
     val num = 600851475143L
     val possiblePrimes = primes.takeWhile { p => p * p <= num }
     val primeFactors = possiblePrimes.filter { num % _ == 0 }
     primeFactors.last
   }

  /**
   * Largest palindrome product
   * http://projecteuler.net/problem=4
   *
   * A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 99.
   * Find the largest palindrome made from the product of two 3-digit numbers.
   */
  def prob004: Long = {
    def isPalindrome(num: Long) = {
      val str = num.toString
      str.reverse == str
    }

    val palindromeNumbers = for ( x <- 100 to 999;
                                  y <- 100 to 999;
                                  prod = x * y if isPalindrome(prod)) yield prod
    palindromeNumbers.max
  }

  /**
   * Smallest multiple
   * http://projecteuler.net/problem=5
   *
   * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
   *
   * What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
   */
  def prob005: Long = {
    import Maths.lcm
    def multiLcm(a: Long, xs: List[Long]): Long = xs match {
      case Nil => a
      case b::Nil => lcm(a, b)
      case b::xs => multiLcm(lcm(a, b), xs)
    }

    multiLcm (1L, (2L to 20L).toList)
  }
  /* brue force method (slow): */
  def prob005_bruteforce: Long = {
    @tailrec
    def isDivisibleByAll(l: Long, range: List[Long]): Boolean = { range match {
      case Nil => true
      case x::xs if l % x != 0 => false
      case _::xs => isDivisibleByAll(l, xs)
    }}

    val twentyAndBelow = (20L to 2L by -1).toList // reverse order makes for more efficient looping

    @tailrec
    def findFirstDivisible(n: Long): Long = if (isDivisibleByAll(n, twentyAndBelow)) n else findFirstDivisible(n + 1)
    findFirstDivisible(1)
  }

  /**
   * Sum square difference
   * http://projecteuler.net/problem=6
   *
   * The sum of the squares of the first ten natural numbers is,
   *            1^2 + 2^2 + ... + 10^2 = 385
   *
   * The square of the sum of the first ten natural numbers is,
   *            (1 + 2 + ... + 10)^2 = 55^2 = 3025
   * Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
   *
   * Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
   */
  def prob006: Long = {
    // see http://en.wikipedia.org/wiki/Triangular_number
    val rangeSum = 100 * (100 + 1)/2
    val squareOfSum = rangeSum * rangeSum

    // see http://en.wikipedia.org/wiki/Square_pyramidal_number
    val sumOfSquares = 100 * (100 + 1) * (2 * 100 + 1)/6
    squareOfSum - sumOfSquares
  }
  def prob006_bruteforce = {
    val range = 1L to 100L
    val sumOfSquares = range.map { x => x * x }.sum
    val rangeSum = range.sum
    val squareOfSum = rangeSum * rangeSum
    squareOfSum - sumOfSquares
  }

  /**
   * 10001st prime
   * http://projecteuler.net/problem=7
   *
   * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
   * What is the 10 001st prime number?
   */
  def prob007: Long = primes(10000) // remember, the stream's index is zero based!

  /**
   * Largest product in a series
   * http://projecteuler.net/problem=8
   *
   * Find the greatest product of five consecutive digits in the 1000-digit number.
   *
   *           73167176531330624919225119674426574742355349194934
   *           96983520312774506326239578318016984801869478851843
   *           85861560789112949495459501737958331952853208805511
   *           12540698747158523863050715693290963295227443043557
   *           66896648950445244523161731856403098711121722383113
   *           62229893423380308135336276614282806444486645238749
   *           30358907296290491560440772390713810515859307960866
   *           70172427121883998797908792274921901699720888093776
   *           65727333001053367881220235421809751254540594752243
   *           52584907711670556013604839586446706324415722155397
   *           53697817977846174064955149290862569321978468622482
   *           83972241375657056057490261407972968652414535100474
   *           82166370484403199890008895243450658541227588666881
   *           16427171479924442928230863465674813919123162824586
   *           17866458359124566529476545682848912883142607690042
   *           24219022671055626321111109370544217506941658960408
   *           07198403850962455444362981230987879927244284909188
   *           84580156166097919133875499200524063689912560717606
   *           05886116467109405077541002256983155200055935729725
   *           71636269561882670428252483600823257530420752963450
   */
  def prob008: Long = {
    def prod(numString: String) = numString.map(_ - '0').product

    val str = "73167176531330624919225119674426574742355349194934" +
              "96983520312774506326239578318016984801869478851843" +
              "85861560789112949495459501737958331952853208805511" +
              "12540698747158523863050715693290963295227443043557" +
              "66896648950445244523161731856403098711121722383113" +
              "62229893423380308135336276614282806444486645238749" +
              "30358907296290491560440772390713810515859307960866" +
              "70172427121883998797908792274921901699720888093776" +
              "65727333001053367881220235421809751254540594752243" +
              "52584907711670556013604839586446706324415722155397" +
              "53697817977846174064955149290862569321978468622482" +
              "83972241375657056057490261407972968652414535100474" +
              "82166370484403199890008895243450658541227588666881" +
              "16427171479924442928230863465674813919123162824586" +
              "17866458359124566529476545682848912883142607690042" +
              "24219022671055626321111109370544217506941658960408" +
              "07198403850962455444362981230987879927244284909188" +
              "84580156166097919133875499200524063689912560717606" +
              "05886116467109405077541002256983155200055935729725" +
              "71636269561882670428252483600823257530420752963450"
    val prods = for(str <- str.sliding(5, 1).toList) yield prod(str)
    prods.max
  }

  /**
   * Special Pythagorean triplet
   * http://projecteuler.net/problem=9
   *
   * A Pythagorean triplet is a set of three natural numbers, a  b  c, for which,
   * a^2 + b^2 = c^2
   * For example, 32 + 42 = 9 + 16 = 25 = 52.
   *
   * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
   * Find the product abc.
   */
  def prob009: Long = {
    /** based on Euclid's formula. See http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple */
    def pythTriples(limit: Long) = {
      import scala.math.{floor, sqrt}
      // by Euclid's formula, with m>n
      // a = m^2 - n^2, b = 2mn, c = m^2 - n^2
      // if a + b + c <= limit
      // => m^2 - n^2 + 2mn + m^2 - n^2 <= limit
      // => 2m(m+n) <= limit
      // => m(m+n) <= limit/2
      // => m < sqrt(limit/2) and, since n<m, by implication n < sqrt(limit/2)
      val l = floor(sqrt(limit/2)).toLong
      for(n <- 1L to l;
          m <- (n + 1L) to l;
          m2 = m * m;
          n2 = n * n;
          a = m2 - n2;
          b = 2 * m * n;
          c = m2 + n2) yield (a, b, c)
    }

    pythTriples(1000).filter { case (a, b, c) => a + b + c == 1000 }
           .map { case (a, b, c) => a * b * c }
           .head
  }

  def prob009_bruteforce: Long = { // naive brute force takes long to complete
    val triples = for (a <- (1 to 1000);
         b <- (a to 1000);
         c <- (b to 1000) if (a*a + b*b == c*c))
       yield (a, b, c)
    triples.filter { case (a, b, c) => a + b + c == 1000 }
           .map { case (a, b, c) => a * b * c }
           .head
  }


  /**
   * Summation of primes
   * http://projecteuler.net/problem=10
   *
   * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
   *
   * Find the sum of all the primes below two million.
   */
  def prob010: Long = ???
}
